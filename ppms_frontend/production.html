<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPMS - 생산</title>
    <link rel="stylesheet" href="common.css">
    <link rel="stylesheet" href="header.css">
    <link rel="stylesheet" href="footer.css">
    <link rel="stylesheet" href="production.css">
    <link href="https://hangeul.pstatic.net/hangeul_static/css/bmdohyeon.css" rel="stylesheet">
    <link href="https://hangeul.pstatic.net/hangeul_static/css/bmjua.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
</head>

<body>
    <div class="page-container">
        <header class="main-header">
            <div class="header-left"><a href="index.html">
                    <picture>
                        <source srcset="logo.avif" type="image/avif"><img src="logo.png" alt="필리아텔레콤 로고"
                            class="header-logo">
                    </picture>
                </a>
                <div id="current-week-display" class="common-box font-15pt clickable-box"></div>
            </div>
            <div class="header-center">
                <div class="common-box font-35pt">생산(SMD)</div>
            </div>
            <div class="header-right">
                <div class="common-box font-15pt time-display" id="current-time"></div>
            </div>
        </header>

        <main class="content-area">
            <div id="schedule-display-area"></div>
        </main>

        <footer class="main-footer">
            <div class="footer-left">
                <div class="common-box font-15pt clickable-box" id="reg-schedule-btn">생산일정등록</div>
            </div>
            <div class="footer-center">
                <div class="common-box font-15pt clickable-box" id="back-btn"><i class="fas fa-arrow-left"></i></div>
                <div class="common-box font-15pt clickable-box" id="home-btn"><i class="fas fa-home"></i></div>
                <div class="common-box font-15pt clickable-box" id="forward-btn"><i class="fas fa-arrow-right"></i>
                </div>
            </div>
            <div class="footer-right">
                <div class="common-box font-15pt clickable-box" id="prev-data-btn">이전데이터</div>
            </div>
        </footer>
    </div>

    <div class="dropup-overlay" id="week-selector-dropup">
        <div class="dropup-content">
            <div class="grid-container" id="week-selector-grid"></div>
        </div>
    </div>

    <div class="modal-overlay" id="schedule-modal">
        <div class="modal-window">
            <button class="close-btn" id="close-modal-btn">&times;</button>
            <h2 class="modal-title" id="modal-title"></h2>
            <div class="modal-content">
                <section class="line-schedule-section">
                    <div class="line-header">
                        <h3 class="line-title">A라인</h3>
                    </div>
                    <div class="table-container">
                        <table class="editable-table registration-table">
                            <colgroup>
                                <col style="width: 5%;">
                                <col style="width: 10%;">
                                <col style="width: 7%;">
                                <col style="width: 20%;">
                                <col style="width: 8%">
                                <col style="width: 10%;">
                                <col style="width: 10%;">
                                <col style="width: 20%;">
                                <col style="width: 10%;">
                            </colgroup>
                            <thead>
                                <tr>
                                    <th>생산라인</th>
                                    <th>업체</th>
                                    <th>주문연도</th>
                                    <th>모델명</th>
                                    <th>주문월</th>
                                    <th>T/B</th>
                                    <th>LOT</th>
                                    <th>생산예정일</th>
                                    <th>추가/삭제</th>
                                </tr>
                            </thead>
                            <tbody id="schedule-table-body-A"></tbody>
                        </table>
                    </div>
                </section>
                <section class="line-schedule-section">
                    <div class="line-header">
                        <h3 class="line-title">B라인</h3>
                    </div>
                    <div class="table-container">
                        <table class="editable-table registration-table">
                            <colgroup>
                                <col style="width: 5%;">
                                <col style="width: 10%;">
                                <col style="width: 7%;">
                                <col style="width: 20%;">
                                <col style="width: 8%">
                                <col style="width: 10%;">
                                <col style="width: 10%;">
                                <col style="width: 20%;">
                                <col style="width: 10%;">
                            </colgroup>
                            <thead>
                                <tr>
                                    <th>생산라인</th>
                                    <th>업체</th>
                                    <th>주문연도</th>
                                    <th>모델명</th>
                                    <th>주문월</th>
                                    <th>T/B</th>
                                    <th>LOT</th>
                                    <th>생산예정일</th>
                                    <th>추가/삭제</th>
                                </tr>
                            </thead>
                            <tbody id="schedule-table-body-B"></tbody>
                        </table>
                    </div>
                </section>
                <section class="line-schedule-section">
                    <div class="line-header">
                        <h3 class="line-title">C라인</h3>
                    </div>
                    <div class="table-container">
                        <table class="editable-table registration-table">
                            <colgroup>
                                <col style="width: 5%;">
                                <col style="width: 10%;">
                                <col style="width: 7%;">
                                <col style="width: 20%;">
                                <col style="width: 8%">
                                <col style="width: 10%;">
                                <col style="width: 10%;">
                                <col style="width: 20%;">
                                <col style="width: 10%;">
                            </colgroup>
                            <thead>
                                <tr>
                                    <th>생산라인</th>
                                    <th>업체</th>
                                    <th>주문연도</th>
                                    <th>모델명</th>
                                    <th>주문월</th>
                                    <th>T/B</th>
                                    <th>LOT</th>
                                    <th>생산예정일</th>
                                    <th>추가/삭제</th>
                                </tr>
                            </thead>
                            <tbody id="schedule-table-body-C"></tbody>
                        </table>
                    </div>
                </section>
            </div>
            <div class="modal-footer">
                <div class="common-box font-15pt clickable-box reset-btn" id="reset-btn">초기화</div>
                <div class="common-box font-15pt clickable-box" id="save-all-btn">저장</div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="notes-modal">
        <div class="modal-window large-modal">
            <button class="close-btn" id="close-notes-modal-btn">&times;</button>
            <h2 class="modal-title">비고 / 주의사항 관리</h2>

            <div class="notes-tab-nav">
                <button class="tab-btn active" data-tab="A">A 라인</button>
                <button class="tab-btn" data-tab="B">B 라인</button>
                <button class="tab-btn" data-tab="C">C 라인</button>
            </div>

            <div class="modal-content notes-modal-content">
                <div class="notes-tab-content active" id="notes-content-A">
                </div>
                <div class="notes-tab-content" id="notes-content-B">
                </div>
                <div class="notes-tab-content" id="notes-content-C">
                </div>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="export-choice-modal">
        <div class="modal-window small-modal">
            <button class="close-btn" id="close-export-modal-btn">&times;</button>
            <h3 class="modal-title">다운로드 형식 선택</h3>
            <div class="modal-content choice-buttons">
                <div id="export-plan-btn" class="common-box font-15pt clickable-box">
                    <i class="fas fa-calendar-alt"></i> 생산계획서
                </div>
                <div id="export-report-btn" class="common-box font-15pt clickable-box">
                    <i class="fas fa-file-pdf"></i> 생산보고서
                </div>
            </div>
        </div>
    </div>

    <script src="paperlogy-font.js"></script>

    <script>
        // --- 전역 요소 ---
        const displayArea = document.getElementById('schedule-display-area');
        const contentArea = document.querySelector('.content-area');
        const prevDataBtn = document.getElementById('prev-data-btn');
        const backBtn = document.getElementById('back-btn');
        const homeBtn = document.getElementById('home-btn');
        const forwardBtn = document.getElementById('forward-btn');
        const weekDisplay = document.getElementById('current-week-display');
        const regScheduleBtn = document.getElementById('reg-schedule-btn');
        const weekSelectorDropup = document.getElementById('week-selector-dropup');
        const weekSelectorGrid = document.getElementById('week-selector-grid');
        const modalOverlay = document.getElementById('schedule-modal');
        const modalWindow = modalOverlay.querySelector('.modal-window');
        const modalTitle = document.getElementById('modal-title');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const saveAllBtn = document.getElementById('save-all-btn');
        const resetBtn = document.getElementById('reset-btn');
        const downloadExcelBtn = document.getElementById('download-excel-btn');
        const downloadPdfBtn = document.getElementById('download-pdf-btn');
        const exportChoiceModal = document.getElementById('export-choice-modal');
        const closeExportModalBtn = document.getElementById('close-export-modal-btn');
        const exportExcelBtn = document.getElementById('export-excel-btn');
        const exportPdfBtn = document.getElementById('export-pdf-btn');
        const lineControls = {
            'A': { tableBody: document.getElementById('schedule-table-body-A'), addBtn: document.querySelector('.plus-btn[data-line="A"]'), removeBtn: document.querySelector('.minus-btn[data-line="A"]') },
            'B': { tableBody: document.getElementById('schedule-table-body-B'), addBtn: document.querySelector('.plus-btn[data-line="B"]'), removeBtn: document.querySelector('.minus-btn[data-line="B"]') },
            'C': { tableBody: document.getElementById('schedule-table-body-C'), addBtn: document.querySelector('.plus-btn[data-line="C"]'), removeBtn: document.querySelector('.minus-btn[data-line="C"]') }
        };
        const notesModal = document.getElementById('notes-modal');
        const closeNotesModalBtn = document.getElementById('close-notes-modal-btn');
        const notesTabNav = notesModal.querySelector('.notes-tab-nav');
        const notesContentContainer = notesModal.querySelector('.notes-modal-content');

        let currentView = { mode: 'current_week', data: {} };
        let viewHistory = [];
        let forwardHistory = []; // ✨ 앞으로 가기 기록을 위한 배열 추가
        let currentSelectedWeekInfo = {};
        let managerList = [];
        let companyList = [];

        document.addEventListener('DOMContentLoaded', () => {

            // ▼▼▼ [수정된 핵심 로직] ▼▼▼
            // 1. 페이지 URL에 포함된 파라미터(year, month, week)를 읽습니다.
            const urlParams = new URLSearchParams(window.location.search);
            const year = urlParams.get('year');
            const month = urlParams.get('month');
            const week = urlParams.get('week');

            if (year && month && week) {
                // 2. (드릴다운) URL에 파라미터가 있으면, 해당 주차를 바로 표시합니다.
                displayScheduleForWeek(parseInt(year), parseInt(month), parseInt(week));
            } else {
                // 3. (기본) URL에 파라미터가 없으면, '현재 주차'를 표시합니다.
                displayCurrentWeekSchedule();
            }

            // 모든 버튼과 요소에 대한 이벤트 리스너를 이 안에서 연결합니다.
            prevDataBtn.addEventListener('click', cycleViewMode);
            backBtn.addEventListener('click', goBackView);
            homeBtn.addEventListener('click', () => window.location.href = 'index.html');
            forwardBtn.addEventListener('click', goForwardView);
            regScheduleBtn.addEventListener('click', openWeekSelectorDropup);
            weekSelectorDropup.addEventListener('click', handleWeekSelection);
            saveAllBtn.addEventListener('click', saveSchedules);
            resetBtn.addEventListener('click', resetSchedules);
            closeModalBtn.addEventListener('click', closeModal);
            modalOverlay.addEventListener('click', closeModal);
            modalWindow.addEventListener('click', (e) => e.stopPropagation());
            modalWindow.addEventListener('click', function (event) {
                const target = event.target;


                // '+' 버튼 클릭 시: 바로 아래에 새 행 추가
                if (target.classList.contains('add-row-btn')) {
                    const currentRow = target.closest('tr');
                    const tableBody = currentRow.closest('tbody');
                    const line = tableBody.id.slice(-1); // 'A', 'B', 'C' 추출
                    addNewScheduleRow(tableBody, line, currentRow);
                }

                // '-' 버튼 클릭 시: 해당 행 삭제
                if (target.classList.contains('delete-row-btn')) {
                    const currentRow = target.closest('tr');
                    const tableBody = currentRow.closest('tbody');
                    // 최소 1개의 행은 남겨두기
                    if (tableBody.rows.length > 1) {
                        currentRow.remove();
                    } else {
                        alert('마지막 행은 삭제할 수 없습니다.');
                    }
                }
            });
            modalWindow.addEventListener('input', function (event) {
                const target = event.target;

                // LOT 필드는 숫자와 '/'만 허용
                if (target.dataset.field === 'lot-modal') {
                    const originalValue = target.value;
                    const sanitizedValue = originalValue.replace(/[^0-9/]/g, '');

                    if (originalValue !== sanitizedValue) {
                        target.value = sanitizedValue;
                        showValidationMessage(target, "숫자와 '/'만 입력 가능합니다.");
                    }
                }
            });
            displayArea.addEventListener('input', function (event) {
                const target = event.target;

                // LOT 필드는 숫자와 '/'만 허용
                if (target.dataset.field === 'lot') {
                    const originalValue = target.value;
                    const sanitizedValue = originalValue.replace(/[^0-9/]/g, '');

                    if (originalValue !== sanitizedValue) {
                        target.value = sanitizedValue;
                        showValidationMessage(target, "숫자와 '/'만 입력 가능합니다.");
                    }
                }
                // ▼▼▼ [수정] '실생산' 필드는 숫자만 허용하는 로직 추가 ▼▼▼
                else if (target.dataset.field === 'actualProd') {
                    const originalValue = target.value;
                    const sanitizedValue = originalValue.replace(/[^0-9]/g, ''); // 숫자 이외의 모든 문자 제거

                    if (originalValue !== sanitizedValue) {
                        target.value = sanitizedValue;
                        showValidationMessage(target, "숫자만 입력 가능합니다.");
                    }
                }
            });

            // displayArea에 대한 통합 클릭 이벤트 리스너
            displayArea.addEventListener('click', function (event) {
                const target = event.target;
                if (target.classList.contains('period-btn')) {
                    const { view, year, month, week } = target.dataset;
                    navigateToView(view, { year: parseInt(year), month: parseInt(month), weekNum: parseInt(week) });
                }
                if (target.closest('#open-export-modal-btn')) {
                    exportChoiceModal.classList.add('visible');
                }
                if (target.closest('#open-notes-modal-btn')) {
                    openNotesModal();
                }
            });

            displayArea.addEventListener('change', handleTableInputChange);

            // 다운로드 모달 관련 요소 가져오기 및 이벤트 리스너
            const exportChoiceModal = document.getElementById('export-choice-modal');
            const closeExportModalBtn = document.getElementById('close-export-modal-btn');
            // ✨ 새 ID로 버튼 요소 가져오기
            const exportPlanBtn = document.getElementById('export-plan-btn');
            const exportReportBtn = document.getElementById('export-report-btn');

            function closeExportModal() {
                exportChoiceModal.classList.remove('visible');
            }
            closeExportModalBtn.addEventListener('click', closeExportModal);
            exportChoiceModal.addEventListener('click', closeExportModal);
            exportChoiceModal.querySelector('.modal-window').addEventListener('click', (e) => e.stopPropagation());

            exportPlanBtn.addEventListener('click', async () => { // [수정] async 추가
                await generateProductionPdf('plan'); // [수정] await 추가
                closeExportModal();
            });
            exportReportBtn.addEventListener('click', async () => { // [수정] async 추가
                await generateProductionPdf('report'); // [수정] await 추가
                closeExportModal();
            });

            function closeNotesModal() {
                notesModal.classList.remove('visible');
            }
            closeNotesModalBtn.addEventListener('click', closeNotesModal);
            notesModal.addEventListener('click', (e) => {
                if (e.target === notesModal) closeNotesModal();
            });
            notesModal.querySelector('.modal-window').addEventListener('click', (e) => e.stopPropagation());

            // 탭 클릭 이벤트
            notesTabNav.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-btn')) {
                    const tabName = e.target.dataset.tab;
                    // 모든 탭 버튼과 탭 내용에서 active 클래스 제거
                    notesTabNav.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    notesContentContainer.querySelectorAll('.notes-tab-content').forEach(content => content.classList.remove('active'));
                    // 클릭된 탭 버튼과 해당 내용에 active 클래스 추가
                    e.target.classList.add('active');
                    document.getElementById(`notes-content-${tabName}`).classList.add('active');
                }
            });

            // 노트 자동 저장 이벤트 (textarea에서 포커스가 벗어날 때)
            notesContentContainer.addEventListener('change', handleNoteSave);
        });



        // --- 기능 함수들 ---

        // 기존 showValidationMessage 함수를 아래 코드로 교체
        function showValidationMessage(targetElement, message) {
            const parentCell = targetElement.parentElement;
            let messageEl = parentCell.querySelector('.validation-message');

            if (!messageEl) {
                messageEl = document.createElement('span');
                messageEl.className = 'validation-message';
                parentCell.appendChild(messageEl);
            }

            messageEl.textContent = message;
            messageEl.classList.add('visible');

            // ✨ 수정된 부분:
            // 이전에 이 메시지'만'을 위한 타이머가 있었다면 취소
            const existingTimeout = messageEl.dataset.timeoutId;
            if (existingTimeout) {
                clearTimeout(existingTimeout);
            }

            // 새로운 타이머를 설정하고, 그 ID를 메시지 요소 자체에 저장
            const newTimeout = setTimeout(() => {
                messageEl.classList.remove('visible');
            }, 2000);
            messageEl.dataset.timeoutId = newTimeout;
        }
        async function loadMasterData() {
            try {
                // 두 API를 동시에 호출하고 기다림
                const [managerRes, companyRes] = await Promise.all([
                    fetch('http://127.0.0.1:5000/api/production/managers'),
                    fetch('http://127.0.0.1:5000/api/production/companies')
                ]);

                managerList = await managerRes.json();
                companyList = await companyRes.json();
                console.log("마스터 데이터 로드 완료:", managerList, companyList);

            } catch (error) {
                console.error("마스터 데이터 로딩 실패:", error);
                alert("담당자/업체 목록을 불러오는 데 실패했습니다.");
            }
        }
        function saveSchedules() {
            const allSchedules = [];
            for (const line in lineControls) {
                const tableBody = lineControls[line].tableBody;
                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const rowId = row.dataset.scheduleId;

                    // [수정] 인덱스가 아닌 'data-field' 속성으로 정확히 값을 찾습니다.
                    const company = row.querySelector('[data-field="company-modal"]').value;
                    const model = row.querySelector('[data-field="model-modal"]').value;
                    const orderYear = row.querySelector('[data-field="orderYear"]').value;
                    const orderMonth = row.querySelector('[data-field="orderMonth"]').value;
                    const lot = row.querySelector('[data-field="lot-modal"]').value;
                    const tb = row.querySelector('[data-field="tb-modal"]').value;
                    const startDate = row.querySelector('.start-date-select').value;
                    const endDate = row.querySelector('.end-date-select').value;

                    if (company || model || lot) {
                        allSchedules.push({
                            id: rowId ? parseInt(rowId) : null,
                            line: row.querySelector('.line-cell').textContent,
                            company,
                            model,
                            orderYear: parseInt(orderYear),
                            orderMonth: orderMonth,
                            lot: lot,
                            tb: tb,
                            startDate: startDate,
                            endDate: endDate
                        });
                    }
                });
            }

            const dataToSend = {
                weekInfo: currentSelectedWeekInfo,
                schedules: allSchedules
            };

            fetch('http://127.0.0.1:5000/api/production/schedules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(dataToSend),
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        alert(data.message);
                        closeModal();
                        renderContent();
                    } else {
                        alert("저장 중 오류 발생: " + (data.error || '알 수 없는 오류'));
                    }
                })
                .catch(error => {
                    console.error('저장 중 오류 발생:', error);
                    alert('데이터 저장에 실패했습니다. 백엔드 서버를 확인하세요.');
                });
        }
        async function resetSchedules() {
            if (confirm('정말로 해당 주차의 모든 일정을 초기화하시겠습니까?\nDB에 저장된 내용이 영구적으로 삭제됩니다.')) {

                // ▼▼▼ [수정] sessionStorage.removeItem 대신 DELETE API 호출 ▼▼▼
                const { year, month, weekNum } = currentSelectedWeekInfo;
                try {
                    const response = await fetch(`http://127.0.0.1:5000/api/production/schedules?year=${year}&month=${month}&weekNum=${weekNum}`, {
                        method: 'DELETE'
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || '삭제 중 오류 발생');
                    }

                    // [기존 로직] DB에서 삭제 성공 시, 화면의 테이블도 비우고 1줄씩 새로 추가
                    for (const line in lineControls) {
                        const control = lineControls[line];
                        control.tableBody.innerHTML = '';
                        addNewScheduleRow(control.tableBody, line); // 최소 1줄 보장 (수정된 openModal 로직과 동일하게)
                    }
                    alert('일정이 성공적으로 초기화되었습니다.');

                } catch (error) {
                    console.error('초기화 실패:', error);
                    alert('일정 초기화에 실패했습니다. 백엔드 서버를 확인하세요.');
                }
            }
        }

        function openWeekSelectorDropup() {
            const viewYear = currentView.data.year || new Date().getFullYear();
            const viewMonth = currentView.data.month ? currentView.data.month - 1 : new Date().getMonth();

            const productionWeeksSet = getProductionWeeksInMonth(viewYear, viewMonth);
            const weekNumbers = Array.from(productionWeeksSet).sort((a, b) => a - b);

            weekSelectorGrid.innerHTML = '';
            weekNumbers.forEach(weekNum => {
                const weekBox = document.createElement('div');
                weekBox.className = 'week-box';
                // 텍스트도 '보고 있는 달' 기준으로 표시
                weekBox.textContent = `${viewMonth + 1}월 ${weekNum}주차`;
                weekBox.dataset.year = viewYear;
                weekBox.dataset.month = viewMonth + 1;
                weekBox.dataset.week = weekNum;
                weekSelectorGrid.appendChild(weekBox);
            });
            weekSelectorDropup.classList.add('visible');
        }

        function closeWeekSelectorDropup() {
            weekSelectorDropup.classList.remove('visible');
        }

        function handleWeekSelection(event) {
            const target = event.target;
            if (target.classList.contains('week-box')) {
                const { year, month, week } = target.dataset;
                const weekInfo = { year: parseInt(year), month: parseInt(month), weekNum: parseInt(week) };
                closeWeekSelectorDropup();
                openModal(weekInfo);
            } else if (target.id === 'week-selector-dropup') {
                closeWeekSelectorDropup();
            }
        }
        async function openModal(weekInfo) {
            currentSelectedWeekInfo = weekInfo;
            modalTitle.textContent = `${weekInfo.month}월${weekInfo.weekNum}주차 일정 등록`;

            for (const line in lineControls) {
                if (lineControls[line].tableBody) {
                    lineControls[line].tableBody.innerHTML = '';
                }
            }

            try {
                // ▼▼▼ [신규] 모달을 열기 전, 업체/담당자 목록을 먼저 불러옵니다. ▼▼▼
                await loadMasterData();

                // (기존 fetch 로직)
                const response = await fetch(`http://127.0.0.1:5000/api/production/schedules?year=${weekInfo.year}&month=${weekInfo.month}&weekNum=${weekInfo.weekNum}`);
                const savedData = await response.json();

                if (savedData.length > 0) {
                    savedData.forEach(data => {
                        const tableBody = lineControls[data.line].tableBody;
                        addNewScheduleRow(tableBody, data.line, data);
                    });
                }

                for (const line in lineControls) {
                    const tableBody = lineControls[line].tableBody;
                    if (tableBody && tableBody.rows.length === 0) {
                        addNewScheduleRow(tableBody, line); // 빈 행 추가
                    }
                }

                modalOverlay.classList.add('visible');

            } catch (error) {
                console.error('모달 데이터 로딩 중 오류:', error);
                alert('일정 데이터를 불러오는 데 실패했습니다. 백엔드 서버를 확인하세요.');
            }
        }


        function closeModal() { modalOverlay.classList.remove('visible'); }
        function addNewScheduleRow(targetTableBody, line, scheduleData = {}, insertAfterRow = null) {
            const newRow = insertAfterRow ?
                targetTableBody.insertRow(insertAfterRow.rowIndex) :
                targetTableBody.insertRow();

            // 'scheduleData'를 올바르게 사용합니다.
            newRow.dataset.scheduleId = scheduleData.id || '';

            const lineCell = `<td class="line-cell">${line}</td>`;

            // 업체 (companyList와 scheduleData 사용)
            const companyOptions = companyList.map(c =>
                `<option value="${c.name}" ${scheduleData.company === c.name ? 'selected' : ''}>${c.name}</option>`
            ).join('');
            const companyCell = `<td><select data-field="company-modal">
                <option value="">-선택-</option>
                ${companyOptions}
            </select></td>`;

            // 모델명 (scheduleData 사용)
            const modelCell = `<td><input type="text" data-field="model-modal" value="${scheduleData.model || ''}"></td>`;

            const orderYearValue = scheduleData.orderYear || currentSelectedWeekInfo.year;
            const orderYearCell = `<td><input type="number" data-field="orderYear" value="${orderYearValue}"></td>`;

            // 주문월 (scheduleData 사용)
            let monthOptions = '';
            for (let i = 1; i <= 12; i++) {
                const monthText = `${i}월분`;
                monthOptions += `<option value="${monthText}" ${scheduleData.orderMonth === monthText ? 'selected' : ''}>${monthText}</option>`;
            }
            const orderMonthCell = `<td><select data-field="orderMonth"><option value="">-선택-</option>${monthOptions}</select></td>`;

            // LOT (scheduleData 사용 - 's'가 아님!)
            const lotCell = `<td><input type="text" data-field="lot-modal" value="${scheduleData.lot || ''}" placeholder="예: 50"></td>`;

            // T/B (T/O, B/O 포함 및 scheduleData 사용)
            const tbCell = `<td><select data-field="tb-modal">
                <option ${scheduleData.tb === 'Top' ? 'selected' : ''}>Top</option>
                <option ${scheduleData.tb === 'Bot' ? 'selected' : ''}>Bot</option>
                <option ${scheduleData.tb === 'T/O' ? 'selected' : ''}>T/O</option>
                <option ${scheduleData.tb === 'B/O' ? 'selected' : ''}>B/O</option>
            </select></td>`;

            // 생산예정일
            const dateCell = `<td><div class="date-select-group"><select class="start-date-select"></select><span>~</span><select class="end-date-select"></select></div></td>`;

            // 동작
            const actionCell = `<td class="row-actions"><button class="action-btn add-row-btn">+</button><button class="action-btn delete-row-btn">-</button></td>`;

            newRow.innerHTML = lineCell + companyCell + orderYearCell + modelCell + orderMonthCell + tbCell + lotCell + dateCell + actionCell;

            // 날짜 드롭다운 채우기
            populateDateSelectors(currentSelectedWeekInfo, newRow);

            // (중요) DB에서 불러온 기존 날짜 값 설정 (scheduleData 사용)
            const selects = newRow.querySelectorAll('select');
            // selects[0] = 업체
            // selects[1] = 주문월
            // selects[2] = T/B
            // selects[3] = 시작일
            // selects[4] = 종료일
            selects[3].value = scheduleData.startDate || '';
            selects[4].value = scheduleData.endDate || '';

            return newRow;
        }

        // [복원] 누락되었던 populateDateSelectors 함수
        function populateDateSelectors(weekInfo, row) {
            if (!row || !weekInfo.year) return;
            const startDateSelect = row.querySelector('.start-date-select');
            const endDateSelect = row.querySelector('.end-date-select');
            startDateSelect.innerHTML = '';
            endDateSelect.innerHTML = '';
            const weekdays = getWeekdaysForWeek(weekInfo.year, weekInfo.month - 1, weekInfo.weekNum);
            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
            weekdays.forEach(item => {
                const optionText = `${item.month}/${item.day}(${dayNames[item.dayOfWeek]})`;
                const startOption = document.createElement('option');
                startOption.value = optionText;
                startOption.textContent = optionText;
                startDateSelect.appendChild(startOption);
                const endOption = document.createElement('option');
                endOption.value = optionText;
                endOption.textContent = optionText;
                endDateSelect.appendChild(endOption);
            });
        }

        function renderContent() {
            const { mode, data } = currentView;
            if (mode === 'current_week' || mode === 'schedule_view') {
                contentArea.classList.add('align-top');
                displayArea.style.marginTop = '5px';
            } else {
                contentArea.classList.remove('align-top');
                displayArea.style.marginTop = '5px';
            }
            switch (mode) {
                case 'past_weeks': displayPastWeeks(); break;
                case 'past_months': displayPastMonths(data.year); break;
                case 'past_years': displayPastYears(); break;
                case 'weeks_of_month': displayWeeksForMonth(data.year, data.month); break;
                case 'schedule_view': displayScheduleForWeek(data.year, data.month, data.weekNum); break;
                case 'current_week':
                default: displayCurrentWeekSchedule(); break;
            }
        }
        function navigateToView(newMode, data = {}) {
            if (currentView.mode !== newMode || JSON.stringify(currentView.data) !== JSON.stringify(data)) {
                viewHistory.push(currentView);
                forwardHistory = []; // ✨ 새로운 이동이므로, 앞으로 가기 기록은 모두 삭제
            }
            currentView = { mode: newMode, data: data };
            renderContent();
        }
        function goBackView() {
            if (viewHistory.length > 0) {
                forwardHistory.push(currentView); // ✨ 현재 뷰를 forwardHistory에 추가
                currentView = viewHistory.pop();
                renderContent();
            } else {
                window.location.href = 'index.html';
            }
        }
        function goForwardView() {
            if (forwardHistory.length > 0) {
                viewHistory.push(currentView); // ✨ 현재 뷰는 이제 과거 기록(viewHistory)이 됨
                currentView = forwardHistory.pop(); // ✨ forwardHistory에서 가장 최근 뷰를 가져옴
                renderContent();
            }
        }
        function cycleViewMode() {
            const currentMode = currentView.mode;
            if (currentMode === 'current_week' || currentMode === 'schedule_view') navigateToView('past_weeks');
            else if (currentMode === 'past_weeks') navigateToView('past_months', { year: new Date().getFullYear() });
            else if (currentMode === 'past_months') navigateToView('past_years');
        }
        function handlePeriodButtonClick(event) {
            const target = event.target;
            if (target.classList.contains('period-btn')) {
                // 'week' 대신 'weekNum'으로 받거나, 객체를 만들 때 'weekNum'으로 지정합니다.
                const { view, year, month, week } = target.dataset;
                navigateToView(view, {
                    year: parseInt(year),
                    month: parseInt(month),
                    weekNum: parseInt(week) // 속성 이름을 weekNum 으로 변경
                });
            }
        }
        function handleTableInputChange(event) {
            const target = event.target;
            const row = target.closest('tr');
            if (!row) return;

            const scheduleId = row.dataset.scheduleId;
            if (!scheduleId) return;

            // 1. 현재 행(row)의 모든 입력 값을 수집합니다.
            const dataToUpdate = {
                manager: row.querySelector('[data-field="manager"]').value,
                company: row.querySelector('[data-field="company"]').value,
                model: row.querySelector('[data-field="model"]').value,
                orderMonth: row.querySelector('[data-field="orderMonth"]').value,
                tb: row.querySelector('[data-field="tb"]').value,
                lot: row.querySelector('[data-field="lot"]').value,
                actualProd: row.querySelector('[data-field="actualProd"]').value,
                prodStart: row.querySelector('[data-field="prodStart"]').value,
                prodEnd: row.querySelector('[data-field="prodEnd"]').value
            };

            // 2. '실생산' 값이 바뀌면 진행률 UI를 즉시 업데이트합니다.
            if (target.dataset.field === 'lot' || target.dataset.field === 'actualProd') {
                const line = row.dataset.line;
                if (line) updateLineProgress(line);
            }

            // 3. 백엔드에 'PUT' 요청을 보내 이 행의 데이터를 DB에 업데이트합니다.
            fetch(`http://127.0.0.1:5000/api/production/schedules/${scheduleId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(dataToUpdate)
            })
                .then(response => response.json())
                .then(data => {
                    if (data.message) {
                        console.log(`ID ${scheduleId} 업데이트 성공`); // 성공 로그
                    } else {
                        console.error('업데이트 실패:', data.error);
                    }
                })
                .catch(error => {
                    console.error('업데이트 중 네트워크 오류:', error);
                });
        }

        function displayCurrentWeekSchedule() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1;
            const weekNum = getCurrentWeekNumber(today);
            currentView = { mode: 'current_week', data: { year, month, weekNum } };
            weekDisplay.textContent = `${year}년 ${month}월 ${weekNum}주차`;
            displayScheduleForWeek(year, month, weekNum);
        }
        async function displayScheduleForWeek(year, month, weekNum) {
            currentView = { mode: 'schedule_view', data: { year, month, weekNum } };
            weekDisplay.textContent = `${year}년 ${month}월 ${weekNum}주차`;
            contentArea.classList.add('align-top');

            // ▼▼▼ [수정] 테이블을 그리기 전, 마스터 데이터를 '먼저' 로드합니다. ▼▼▼
            await loadMasterData();

            // 이제 기존 fetch 로직을 실행합니다.
            fetch(`http://127.0.0.1:5000/api/production/schedules?year=${year}&month=${month}&weekNum=${weekNum}`)
                .then(response => response.json())
                .then(savedData => {
                    // 마스터 데이터가 준비된 상태에서 테이블을 그립니다.
                    displayArea.innerHTML = createScheduleTableHTML(savedData, {}, false);

                    if (savedData.length > 0) {
                        const weekInfo = { year, month, weekNum };
                        populateDateSelectorsForProductionPage(weekInfo, savedData);
                    }
                    ['A', 'B', 'C'].forEach(line => updateLineProgress(line));
                })
                .catch(error => {
                    console.error('일정 로딩 중 오류 발생:', error);
                    displayArea.innerHTML = `<p class="no-data-message" style="text-align: center;">데이터 로딩 실패. 백엔드 서버를 확인하세요.</p>`;
                });
        }
        function updateLineProgress(line) {
            const section = document.querySelector(`.line-schedule-section[data-line="${line}"]`);
            if (!section) return;

            let totalLot = 0;
            let totalActual = 0;

            const rows = section.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const lotInput = row.querySelector('input[data-field="lot"]');
                const actualInput = row.querySelector('input[data-field="actualProd"]');

                totalLot += parseInt(lotInput.value) || 0;
                totalActual += parseInt(actualInput.value) || 0;
            });

            const percentage = totalLot > 0 ? (totalActual / totalLot) * 100 : 0;
            const displayPercentage = Math.min(percentage, 100);

            const bar = document.getElementById(`progress-bar-${line}`);
            const text = document.getElementById(`progress-text-${line}`);
            if (bar) bar.style.width = `${displayPercentage}%`;
            if (text) text.textContent = `${Math.round(displayPercentage)}%`;
        }
        function displayPastWeeks() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth() + 1;
            const currentWeek = getCurrentWeekNumber(today);
            let contentHTML = `<div class="period-selector-grid">`;
            for (let i = 1; i <= currentWeek; i++) {
                contentHTML += `<div class="period-btn" data-view="schedule_view" data-year="${year}" data-month="${month}" data-week="${i}">${month}월 ${i}주차</div>`;
            }
            contentHTML += `</div>`;
            displayArea.innerHTML = contentHTML;
        }
        function displayPastMonths(year) {
            const today = new Date();
            const currentMonth = (today.getFullYear() === year) ? today.getMonth() : 11;
            let contentHTML = `<div class="period-selector-grid">`;
            for (let i = 0; i <= currentMonth; i++) {
                contentHTML += `<div class="period-btn" data-view="weeks_of_month" data-year="${year}" data-month="${i + 1}">${i + 1}월</div>`;
            }
            contentHTML += `</div>`;
            displayArea.innerHTML = contentHTML;
        }
        function displayPastYears() {
            const currentYear = new Date().getFullYear();
            let contentHTML = `<div class="period-selector-grid">`;
            for (let i = 2; i >= 0; i--) {
                const year = currentYear - i;
                contentHTML += `<div class="period-btn" data-view="past_months" data-year="${year}">${year}년</div>`;
            }
            contentHTML += `</div>`;
            displayArea.innerHTML = contentHTML;
        }
        function displayWeeksForMonth(year, month) {
            const productionWeeksSet = getProductionWeeksInMonth(year, month - 1);
            const weekNumbers = Array.from(productionWeeksSet).sort((a, b) => a - b);
            let contentHTML = `<div class="period-selector-grid">`;
            weekNumbers.forEach(weekNum => {
                contentHTML += `<div class="period-btn" data-view="schedule_view" data-year="${year}" data-month="${month}" data-week="${weekNum}">${month}월 ${weekNum}주차</div>`;
            });
            contentHTML += `</div>`;
            displayArea.innerHTML = contentHTML;
        }
        async function openNotesModal() {
            // 1. 현재 주차의 모든 데이터를 DB에서 다시 불러옵니다.
            const { year, month, weekNum } = currentView.data;
            let schedulesData;
            try {
                const response = await fetch(`http://127.0.0.1:5000/api/production/schedules?year=${year}&month=${month}&weekNum=${weekNum}`);
                schedulesData = await response.json();
            } catch (e) {
                alert('데이터 로딩 실패. 서버를 확인하세요.');
                return;
            }

            // 2. 각 라인별로 데이터를 분류합니다.
            const lineData = { A: [], B: [], C: [] };
            schedulesData.forEach(s => {
                if (lineData[s.line]) {
                    lineData[s.line].push(s);
                }
            });

            // 3. 각 라인별 탭 내용을 HTML로 생성합니다.
            for (const line of ['A', 'B', 'C']) {
                const contentEl = document.getElementById(`notes-content-${line}`);
                if (lineData[line].length > 0) {
                    contentEl.innerHTML = lineData[line].map(s => `
                        <div class="note-item">
                            <h4>${s.company || '업체 미입력'} - ${s.model || '모델 미입력'} (LOT: ${s.lot || 'N/A'})</h4>
                            <textarea data-note-id="${s.id}" placeholder="비고/주의사항 입력...">${s.notes || ''}</textarea>
                        </div>
                    `).join('');
                } else {
                    contentEl.innerHTML = `<p class="no-line-data-message">${line}라인은 등록된 일정이 없습니다.</p>`;
                }
            }

            // 4. (참고) 기본으로 A탭이 열리도록 설정 (CSS에서 이미 처리됨)

            // 5. 모달을 엽니다.
            notesModal.classList.add('visible');
        }

        // ▼▼▼ [신규] 노트를 DB에 자동 저장하는 함수 (PATCH API 호출) ▼▼▼
        async function handleNoteSave(event) {
            if (event.target.tagName !== 'TEXTAREA') return;

            const scheduleId = event.target.dataset.noteId;
            const newNoteText = event.target.value;

            try {
                const response = await fetch(`http://127.0.0.1:5000/api/production/schedules/${scheduleId}/notes`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ notes: newNoteText })
                });

                if (!response.ok) {
                    throw new Error('서버 저장 실패');
                }

                console.log(`노트 (ID: ${scheduleId}) 저장 완료.`);
                // (선택사항) 저장 성공 시 사용자에게 피드백 (예: 작은 체크 표시)

            } catch (error) {
                console.error('노트 저장 실패:', error);
                alert('비고/주의사항 저장에 실패했습니다.');
            }
        }
        function createScheduleTableHTML(schedules, progress, isReadOnly = false) {
            const schedulesByLine = { A: [], B: [], C: [] };
            if (schedules && schedules.length > 0) {
                schedules.forEach((schedule, index) => {
                    schedule.originalIndex = index;
                    if (schedulesByLine[schedule.line]) { schedulesByLine[schedule.line].push(schedule); }
                });
            }

            let tableHTML = '';
            for (const line in schedulesByLine) {
                let headerContent = `
            <div class="line-title-container">
                <h3 class="line-title">${line}라인</h3>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill" id="progress-bar-${line}"></div>
                    <span class="progress-bar-text" id="progress-text-${line}">0%</span>
                </div>
            </div>
        `;
                if (line === 'A') {
                    headerContent += `<button id="open-notes-modal-btn" class="icon-btn" title="비고/주의사항"><i class="fas fa-sticky-note"></i></button>`;
                    headerContent += `<button id="open-export-modal-btn" class="icon-btn" title="다운로드"><i class="fas fa-download"></i></button>`;
                }
                tableHTML += `<section class="line-schedule-section" data-line="${line}"><div class="line-header">${headerContent}</div>`;

                if (schedulesByLine[line].length > 0) {

                    tableHTML += `<div class="table-container"><table class="editable-table production-view-table"><colgroup>
                        <col style="width: 6%;">  
                        <col style="width: 6%;"> 
                        <col style="width: auto;"> 
                        <col style="width: 6%;">  
                        <col style="width: 6%;">  
                        <col style="width: 8%;"> 
                        <col style="width: 6%;">  
                        <col style="width: 8%;"> 
                        <col style="width: 8%;"> 
                        <col style="width: 20%;"> </colgroup>
                        <thead><tr>
                        <th>담당자 </th>
                        <th>업체 </th>
                        <th>모델명</th>
                        <th>주문월</th>
                        <th>T/B</th>
                        <th>LOT</th>
                        <th>실생산</th>
                        <th>생산시작일</th>
                        <th>생산종료일</th>
                        <th>생산예정일</th>
                    </tr></thead><tbody>`;

                    // ▼▼▼ [수정] 중복되었던 첫 번째 .map() 루프를 삭제했습니다. ▼▼▼
                    // (첫 번째 루프 삭제됨)

                    // ▼▼▼ [수정] 이 두 번째 .map() 루프가 올바른 코드입니다. ▼▼▼
                    tableHTML += schedulesByLine[line].map(s => {
                        const managerOptions = managerList.map(m =>
                            `<option value="${m.name}" ${s.manager === m.name ? 'selected' : ''}>${m.name}</option>`
                        ).join('');

                        const companyOptions = companyList.map(c =>
                            `<option value="${c.name}" ${s.company === c.name ? 'selected' : ''}>${c.name}</option>`
                        ).join('');

                        // '주문월' 드롭다운용 <option> 태그 목록 생성
                        let monthOptions = '';
                        for (let i = 1; i <= 12; i++) {
                            const monthText = `${i}월분`;
                            monthOptions += `<option value="${monthText}" ${s.orderMonth === monthText ? 'selected' : ''}>${monthText}</option>`;
                        }

                        return `<tr data-schedule-id="${s.id}" data-line="${line}">
                    <td><select class="form-select" data-field="manager">
                        <option value="">-선택-</option>
                        ${managerOptions}
                    </select></td>
                    
                    <td><select class="form-select" data-field="company">
                        <option value="">-선택-</option>
                        ${companyOptions}
                    </select></td>
                    
                    <td><input type="text" class="form-input" data-field="model" value="${s.model || ''}"></td>
                    
                    <td><select class="form-select" data-field="orderMonth">
                        <option value="">-선택-</option>
                        ${monthOptions}
                    </select></td>
                    
                    <td><select class="form-select" data-field="tb">
                        <option ${s.tb === 'Top' ? 'selected' : ''}>Top</option>
                        <option ${s.tb === 'Bot' ? 'selected' : ''}>Bot</option>
                        <option ${s.tb === 'T/O' ? 'selected' : ''}>T/O</option>
                        <option ${s.tb === 'B/O' ? 'selected' : ''}>B/O</option>
                    </select></td>
                    <td><input type="text" class="form-input" data-field="lot" value="${s.lot || ''}"></td>
                    <td><input type="text" class="form-input" data-field="actualProd" value="${s.actualProd || ''}"></td>
                    <td><select class="form-select prod-start-date" data-field="prodStart"></select></td>
                    <td><select class="form-select prod-end-date" data-field="prodEnd"></select></td>
                    <td>${s.startDate} ~ ${s.endDate}</td>
                </tr>`;
                    }).join('');
                    tableHTML += `</tbody></table></div>`;
                } else {
                    tableHTML += `<p class="no-line-data-message">${line}라인은 등록된 생산 일정이 없습니다.</p>`;
                }
                tableHTML += `</section>`;
            }
            return tableHTML;
        }
        async function generateProductionPdf(reportType) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const isPlan = reportType === 'plan';

            // --- 1. 기본 데이터 로딩 ---
            const { year, month, weekNum } = currentView.data;

            let dbScheduleData;
            try {
                const response = await fetch(`http://127.0.0.1:5000/api/production/schedules?year=${year}&month=${month}&weekNum=${weekNum}`);
                if (!response.ok) throw new Error('서버 응답 오류');
                dbScheduleData = await response.json();
            } catch (error) {
                console.error("PDF 생성 중 데이터 로딩 실패:", error);
                alert("데이터를 불러오는 데 실패했습니다. 백엔드 서버를 확인하세요.");
                return;
            }

            if (dbScheduleData.length === 0) {
                alert("다운로드할 데이터가 없습니다.");
                return;
            }

            addPaperlogyFont(doc);
            doc.setFont('Paperlogy', 'normal');

            // --- 2. 보고서 타입에 따라 제목, 헤더 변경 ---
            const title = isPlan ? `${year}년 ${month}월 ${weekNum}주차 생산계획서` : `${year}년 ${month}월 ${weekNum}주차 생산보고서`;

            // ▼▼▼ [수정] '생산계획서'와 '생산보고서' head에 '주문월' 열 추가 ▼▼▼
            const head = isPlan
                ? [['업체', '모델명', '주문월', 'T/B', 'LOT', '월', '화', '수', '목', '금']]
                : [['담당자', '업체', '모델명', '주문월', 'T/B', 'LOT', '실생산', '월', '화', '수', '목', '금']];

            doc.setFontSize(20);
            doc.text(title, 14, 7);

            // --- 3. 컬럼 스타일 (수정) ---
            const dayColumnWidth = 8;
            const orderMonthWidth = 13; // '주문월' 열 너비

            // ▼▼▼ [수정] columnStyles에 '주문월' 열(2번) 추가 및 인덱스 수정 ▼▼▼
            const columnStyles = isPlan
                ? {
                    0: { cellWidth: 25 }, 1: { cellWidth: 'auto' },
                    2: { cellWidth: orderMonthWidth }, // 주문월
                    3: { cellWidth: 17 }, // T/B
                    4: { cellWidth: 20 }, // LOT
                    5: { cellWidth: dayColumnWidth }, 6: { cellWidth: dayColumnWidth }, 7: { cellWidth: dayColumnWidth }, 8: { cellWidth: dayColumnWidth }, 9: { cellWidth: dayColumnWidth } // 요일
                }
                : {
                    0: { cellWidth: 20 }, 1: { cellWidth: 17 }, 2: { cellWidth: 'auto' },
                    3: { cellWidth: orderMonthWidth }, // 주문월
                    4: { cellWidth: 17 }, // T/B
                    5: { cellWidth: 20 }, // LOT
                    6: { cellWidth: 13 }, // 실생산
                    7: { cellWidth: dayColumnWidth }, 8: { cellWidth: dayColumnWidth }, 9: { cellWidth: dayColumnWidth }, 10: { cellWidth: dayColumnWidth }, 11: { cellWidth: dayColumnWidth } // 요일
                };

            // --- 4. 데이터 그룹화 및 테이블 생성 ---
            const dataByLine = { A: [], B: [], C: [] };
            dbScheduleData.forEach((item) => {
                if (dataByLine[item.line]) {
                    dataByLine[item.line].push(item);
                }
            });

            const daysOrder = ['월', '화', '수', '목', '금'];
            let lastY = 28;

            ['A', 'B', 'C'].forEach(line => {
                const lineItems = dataByLine[line];
                if (lineItems.length > 0) {
                    doc.setFontSize(14);
                    doc.setFont('Paperlogy', 'normal');
                    doc.text(`${line}라인`, 14, lastY + 10);

                    const body = lineItems.map(item => {
                        const getDay = (dateStr) => (dateStr && dateStr.match(/\(([^)]+)\)/)) ? dateStr.match(/\(([^)]+)\)/)[1] : null;

                        const startDay = isPlan ? getDay(item.startDate) : getDay(item.actualStartDate);
                        const endDay = isPlan ? getDay(item.endDate) : getDay(item.actualEndDate);

                        const startIndex = daysOrder.indexOf(startDay);
                        const endIndex = daysOrder.indexOf(endDay);
                        const finalEndIndex = (startIndex > -1 && endIndex === -1) ? startIndex : endIndex;

                        const dayFlags = daysOrder.map((day, index) => {
                            if (startIndex > -1 && finalEndIndex > -1 && startIndex <= finalEndIndex) {
                                return (index >= startIndex && index <= finalEndIndex) ? 1 : 0;
                            }
                            return 0;
                        });

                        if (isPlan) {
                            // ▼▼▼ [수정] 'item.orderMonth' 추가 ▼▼▼
                            return [item.company, item.model, item.orderMonth || '', item.tb || 'Top', item.lot, ...dayFlags];
                        } else {
                            // ▼▼▼ [수정] 'item.orderMonth' 추가 ▼▼▼
                            return [
                                item.manager || '',
                                item.company,
                                item.model,
                                item.orderMonth || '',
                                item.tb || 'Top',
                                item.lot,
                                item.actualProd || '',
                                ...dayFlags
                            ];
                        }
                    });

                    doc.autoTable({
                        head: head,
                        body: body,
                        startY: lastY + 15,
                        theme: 'grid',
                        styles: { font: 'Paperlogy', fontStyle: 'normal', fontSize: 9, lineWidth: 0.1, lineColor: [150, 150, 150], halign: 'center' },
                        headStyles: { fontStyle: 'normal' },
                        columnStyles: columnStyles,
                        didDrawCell: function (data) {
                            // ▼▼▼ [수정] 요일 시작 인덱스 변경 (isPlan: 4 -> 5, !isPlan: 6 -> 7) ▼▼▼
                            const dayColumnStartIndex = isPlan ? 5 : 7;
                            if (data.column.index >= dayColumnStartIndex && data.cell.section === 'body') {
                                if (data.cell.raw === 1) {
                                    doc.setFillColor(255, 255, 0); // 노란색
                                } else {
                                    doc.setFillColor(255, 255, 255); // 흰색
                                }
                                doc.setDrawColor(150, 150, 150);
                                doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'FD');
                                data.cell.text = [''];
                            }
                        }
                    });

                    lastY = doc.autoTable.previous.finalY;
                }
            });

            // 5. 파일 저장
            const fileName = isPlan ? '생산계획서' : '생산보고서';
            doc.save(`${year}년-${month}월-${weekNum}주차_${fileName}.pdf`);
        }
        function populateDateSelectorsForProductionPage(weekInfo, schedulesData) { // [수정] progressData -> schedulesData
            const weekdays = getWeekdaysForWeek(weekInfo.year, weekInfo.month - 1, weekInfo.weekNum);
            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
            const allStartDateSelects = document.querySelectorAll('.prod-start-date');
            const allEndDateSelects = document.querySelectorAll('.prod-end-date');
            const createOption = (value, text) => { const option = document.createElement('option'); option.value = value; option.textContent = text; return option; };

            allStartDateSelects.forEach(select => {
                const row = select.closest('tr');
                if (!row) return;
                // ▼▼▼ [수정] ID로 DB 데이터를 찾습니다 ▼▼▼
                const scheduleId = parseInt(row.dataset.scheduleId);
                const schedule = schedulesData.find(s => s.id === scheduleId);
                const savedStart = schedule ? schedule.actualStartDate : '-'; // 'actualStartDate' 사용

                select.innerHTML = ''; select.appendChild(createOption('-', '-'));
                weekdays.forEach(item => { const optionText = `${item.month}/${item.day}(${dayNames[item.dayOfWeek]})`; const option = createOption(optionText, optionText); if (optionText === savedStart) option.selected = true; select.appendChild(option); });
            });
            allEndDateSelects.forEach(select => {
                const row = select.closest('tr');
                if (!row) return;
                // ▼▼▼ [수정] ID로 DB 데이터를 찾습니다 ▼▼▼
                const scheduleId = parseInt(row.dataset.scheduleId);
                const schedule = schedulesData.find(s => s.id === scheduleId);
                const savedEnd = schedule ? schedule.actualEndDate : '-'; // 'actualEndDate' 사용

                select.innerHTML = ''; select.appendChild(createOption('-', '-'));
                weekdays.forEach(item => { const optionText = `${item.month}/${item.day}(${dayNames[item.dayOfWeek]})`; const option = createOption(optionText, optionText); if (optionText === savedEnd) option.selected = true; select.appendChild(option); });
            });
        }
        function getWeekdaysForWeek(year, month, weekNum) {
            const weekdays = [];
            const firstDateOfMonth = new Date(year, month, 1);
            const firstDayOfWeek = firstDateOfMonth.getDay();
            let date = new Date(firstDateOfMonth);
            date.setDate(date.getDate() - firstDayOfWeek);
            date.setDate(date.getDate() + (weekNum - 1) * 7);
            for (let i = 0; i < 7; i++) {
                const currentDate = new Date(date);
                currentDate.setDate(date.getDate() + i);
                const dayOfWeek = currentDate.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { weekdays.push({ year: currentDate.getFullYear(), month: currentDate.getMonth() + 1, day: currentDate.getDate(), dayOfWeek: dayOfWeek }); }
            }
            return weekdays;
        }
        function getProductionWeeksInMonth(year, month) {
            const productionWeeks = new Set();
            const lastDateOfMonth = new Date(year, month + 1, 0).getDate();
            for (let day = 1; day <= lastDateOfMonth; day++) {
                const currentDate = new Date(year, month, day);
                const dayOfWeek = currentDate.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    const firstDayOfMonth = new Date(year, month, 1).getDay();
                    const weekNumber = Math.ceil((day + firstDayOfMonth) / 7);
                    productionWeeks.add(weekNumber);
                }
            }
            return productionWeeks;
        }
        function getCurrentWeekNumber(date) {
            const dayOfMonth = date.getDate();
            const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay();
            return Math.ceil((dayOfMonth + firstDayOfMonth) / 7);
        }
        function updateTime() {
            const timeDisplay = document.getElementById('current-time');
            if (!timeDisplay) return;
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const formattedTime = `${year}년 ${month}월 ${day}일 ${hours}시 ${minutes}분`;
            timeDisplay.textContent = formattedTime;
        }
        setInterval(updateTime, 1000);

    </script>
</body>

</html>